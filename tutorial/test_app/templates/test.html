<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swipe Feature</title>
    <style>
        /* 기본 스타일 설정: 페이지를 가운데 정렬하고 배경색을 설정합니다. */
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }

        /* 컨테이너 스타일: 중앙에 사진을 포함하는 카드 크기를 설정합니다. */
        .container {
            position: relative;
            width: 300px;
            height: 400px;
        }

        /* 카드 스타일: 흰색 배경에 그림자와 둥근 모서리를 추가합니다. */
        .card {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }

        .hidden {
            display: none;
        }

        /* 이미지 스타일: 카드 내부에서 이미지를 표시합니다. */
        .card img {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        /* 피드백 스타일: 화면 중앙에 큰 텍스트로 표시합니다. */
        .feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            display: none;
            pointer-events: none;
        }

        /* 좋아요 (하트) 피드백 스타일: 빨간색 텍스트로 설정합니다. */
        .feedback.heart {
            color: red;
        }

        /* 싫어요 피드백 스타일: 파란색 텍스트로 설정합니다. */
        .feedback.dislike {
            color: blue;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <img src="" alt="Swipe Image" class="image">
        </div>
        <div class="card hidden">
            <img src="" alt="Swipe Image" class="image">
        </div>
        <div id="feedback" class="feedback"></div>
    </div>
    <script>
        // 이미지 URL 목록
        const imageUrls = [
            'https://blog.kakaocdn.net/dn/cWfP3E/btqEsD61rvL/ZeAtugh3k3fNiXLyxaywe1/img.jpg',
            'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQhhm9hPnmTtkz4zQJU48ecb_X5kMKPKdwdMUIc-qMfCuxmKXrmc1D04sZuVOnWun_XChU&usqp=CAU',
            'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQOR4saTzFVXZ7gR7LKFzAV0YsxWWni-vtr33WbkZF22I59McrBqJn34-mThpl5q6vhVGM&usqp=CAU',
            // 추가 이미지 URL을 여기에 추가할 수 있습니다.
        ];

        const cards = document.querySelectorAll('.card');
        const feedback = document.getElementById('feedback');
        let currentCard = 0;
        let currentImageIndex = 0;
        let startX = 0;
        let isMouseDown = false;

        // 초기 이미지 로드
        function loadNextImage(cardIndex) {
            const imgElement = cards[cardIndex].querySelector('img');
            imgElement.src = imageUrls[currentImageIndex];
            currentImageIndex = (currentImageIndex + 1) % imageUrls.length;
        }

        // 첫 번째 이미지 로드
        loadNextImage(0);
        // 이건 굳이 해야되나??  loadNextImage(1);


        function handleSwipe(direction) {
            const card = cards[currentCard];
            card.style.transform = `rotate(${direction * 45}deg) translate(${direction * 1000}px, -100px)`;
            card.style.opacity = '30';
            setTimeout(() => {
                card.classList.add('hidden');
                currentCard = (currentCard + 1) % cards.length;
                const nextCard = cards[currentCard];
                nextCard.style.transform = 'none';
                nextCard.style.opacity = '1';
                nextCard.classList.remove('hidden');
                feedback.style.display = 'none';
                loadNextImage(currentCard);  // Load new image
            }, 500);
        }

        cards.forEach(card => {
            card.addEventListener('mousedown', (e) => {
                startX = e.clientX;
                isMouseDown = true;
            });

            card.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;

                const currentX = e.clientX;
                const diffX = currentX - startX;

                if (Math.abs(diffX) > 50) {
                    if (diffX > 0) {
                        feedback.textContent = '❤️';
                        feedback.className = 'feedback heart';
                    } else {
                        feedback.textContent = '👎';
                        feedback.className = 'feedback dislike';
                    }
                    feedback.style.display = 'block';
                } else {
                    feedback.style.display = 'none';
                }
            });

            card.addEventListener('mouseup', (e) => {
                if (!isMouseDown) return;
                isMouseDown = false;

                const endX = e.clientX;
                const diffX = endX - startX;

                if (Math.abs(diffX) > 50) {
                    handleSwipe(diffX > 0 ? 1 : -1);
                } else {
                    feedback.style.display = 'none';
                }
            });

            card.addEventListener('mouseleave', () => {
                isMouseDown = false;
                feedback.style.display = 'none';
            });
        });

        // 추가된 이벤트 리스너: 터치 이벤트
        cards.forEach(card => {
            card.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isMouseDown = true;
            });

            card.addEventListener('touchmove', (e) => {
                if (!isMouseDown) return;

                const currentX = e.touches[0].clientX;
                const diffX = currentX - startX;

                if (Math.abs(diffX) > 50) {
                    if (diffX > 0) {
                        feedback.textContent = '❤️';
                        feedback.className = 'feedback heart';
                    } else {
                        feedback.textContent = '👎';
                        feedback.className = 'feedback dislike';
                    }
                    feedback.style.display = 'block';
                } else {
                    feedback.style.display = 'none';
                }
            });

            card.addEventListener('touchend', (e) => {
                if (!isMouseDown) return;
                isMouseDown = false;

                const endX = e.changedTouches[0].clientX;
                const diffX = endX - startX;

                if (Math.abs(diffX) > 50) {
                    handleSwipe(diffX > 0 ? 1 : -1);
                } else {
                    feedback.style.display = 'none';
                }
            });

            card.addEventListener('touchcancel', () => {
                isMouseDown = false;
                feedback.style.display = 'none';
            });
        });
    </script>
</body>
</html>
